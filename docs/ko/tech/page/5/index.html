<!DOCTYPE html>
<html lang='ko'>

<head>
  <meta charset='utf-8'>

  
  <title>sixmen.com: Tech</title>
  
  
  <meta name='author' content='Sangmin Yoon'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0'>

  <link rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css'>
  <link href='/css/style.css?body=1' rel='stylesheet' type='text/css' media='all'>
  <link href='/css/syntax.css?body=1' rel='stylesheet' type='text/css' media='all'>

  <!--[if lt IE 9]>
  <script src='https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js'></script>
  <script src='https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js'></script>
  <![endif]-->
</head>

<body>
<div class='hp-navbar'>
  <div class='container-fluid'>
    <div class='row'>
      <div class='col-xs-12'>
        
        <nav class='hp-nav'>
          <a class='hp-nav-item'
            href='/ko/'>Home</a>
          <a class='hp-nav-item'
            href='/ko/mylife/'>MyLife</a>
          <a class='hp-nav-item'
            href='/ko/travel/'>Travel</a>
          <a class='hp-nav-item active'
            href='/ko/tech/'>Tech</a>
          <a class='hp-nav-item'
            href='/ko/tags/'>Tags</a>
          <a class='hp-nav-item pull-right' href='/en/'>English</a>
        </nav>
      </div>
    </div>
  </div>
</div>



<div class='container'>

  <div class='row' style='margin-top: 20px;'>

    <div class='col-sm-10 col-sm-offset-1'>
      
      <div class='panel panel-default'>
        <div class='panel-heading'>
          <h2 class='posts-title'><a href='/ko/tech/2017-04-07-1-croquis-stack-mithril/'>크로키의 스택 - Mithril</a></h2>
          <p class='posts-date'>07 Apr 2017</p>
        </div>
        <div class='panel-body'>
          <p>이번 글에서는 크로키가 사용하는 스택 중
클라이언트 JavaScript 프레임워크(client-side JavaScript framework)에 대해서
소개해볼까 합니다.</p>
<p>TD;DR) 크로키에서는 <a href="http://backbonejs.org/">Backbone</a>, <a href="http://angular.io/">Angular</a>를 거쳐
현재는 <a href="http://mithril.js.org/">Mithril</a>이라는 프레임워크를 사용하고 있습니다.</p>
<hr>
<p>크로키는 현재 지그재그라는 서비스에 주력하고 있지만, 지그재그가 첫 제품은 아닙니다.
창업 후 여러 제품을 만들었는데 모두 네이티브 모바일 앱이 기본이였고,
일반 사용자를 위한 웹 서비스는 없었습니다.
그렇다고 전혀 웹 어플리케이션을 개발하지 않는 것은 아니고,
크로키 내부 직원이나 한정된 외부 사용자를 위한 웹 어플리케이션은 꾸준히 개발해왔습니다.</p>
<hr>
<p>2012년 초, 처음 개발하던 iOS 앱(쿠키단어장)은 Vanilla JS와 UIWebView로 시작했습니다.
(1주일 정도 개발하다가 JavaScript에서 <a href="http://coffeescript.org/">CoffeeScript</a>로 전환했습니다.)
하지만 2주 정도 개발하다가 한계를 느껴 네이티브로 전환했습니다.</p>
<hr>
<p>2012년 여름 개발을 시작한 두번째 제품(Teamable)은 모바일 웹 앱으로 시작했습니다.
그때 서버쪽에서 HTML 렌더링을 하기 보다는 클라이언트에서 렌더링을 하는 구조로 가져가기로 했습니다.
각각의 장단점을 생각해보고 결정한 것이지만, 서버쪽에서 할 일을 클라이언트에 맡김으로써 서버 비용이
줄어든다는 생각이 컸던 것으로 기억합니다. (사실 몇명쓰지도 않는 서비스에서 아무 차이도 없지만)</p>
<p>이때 선택한 클라이언트 JavaScript 프레임워크는 Backbone이였습니다. (당시 0.9.2)
당시에도 Angular는 있었던 것 같은데, 제가 접하는 범위에서는 Backbone이 대세였습니다.</p>
<p>얼마 후 웹 앱이 아니라 모바일 앱을 만드는 방향으로 전환했고,
잠시 Apache Cordova(PhoneGap)을 시도해봤지만 결국은 네이티브 모바일 앱으로 전환했습니다.
하지만 그때까지 개발된 JavaScript 클라이언트 소스는 간이 관리 사이트에서 계속 사용됐습니다.</p>
<hr>
<p>2013년 4월부터는 두번째 제품을 바탕으로 외주를 받은 세번째 제품의 개발을 시작했습니다.
여기에 한정된 외부 사용자를 위한 관리 사이트가 필요했고, 자연스럽게 Backbone을 사용했습니다.
(그리고 Bootstrap을 사용하기 시작했습니다.)</p>
<p>이때부터 SPA에 대한 관점이 정리된 것 같습니다.
저희는 모바일 앱이 기본이다보니 서버쪽은 여기에 데이터를 제공하는 API 위주로 개발이 이뤄졌습니다.
그리고 SPA는 이 API를 동일하게 써서 개발할 수 있다는 장점이 있었습니다.
SPA의 단점은 무시할 만 했습니다.
(SEO - 로그인이 필요한 사이트로 검색 엔진 연동 자체가 의미 없음, 큰 파일 크기로 인한 로딩 속도 - 한정된 사용자에게는 별로 이슈 안 됨)</p>
<hr>
<p>2014년이 되어 세번째 제품의 2014년 버전 개발에 들어갔습니다.</p>
<p>2013년 버전에서 Backbone으로 만든 관리 사이트가 점점 커지면서 소스 관리에 한계를 느꼈고(파일도 단순히 concat으로 합치고 있었습니다)
다른 프레임워크를 찾게 되었고 그때 선택한 것이 Angular였습니다. (당시 1.2)
<a href="http://yeoman.io/">Yeoman</a>을 통해 Angular를 프레임워크로 쓰고, <a href="https://gruntjs.com/">Grunt</a>를 빌드 툴로 쓰는 프로젝트를 생성해
새로 관리 사이트를 만들었습니다.</p>
<p>기존 기능이 계속 유지됐으면 코드를 완전히 재작성하는게 쉽지 않았을 수도 있지만,
2013년 버전과 2014년 버전의 요구 사항이 많이 달랐기에 과감하게 처음부터 작성을 했습니다.</p>
<hr>
<p>그렇게 2014년에는 Angular를 써서 원하는 결과물을 만들 수 있었습니다.
하지만 쓰면 쓸 수록 Angular는 저와 맞지 않는 다는 생각이 들었습니다.
보통 Angular에 속도에 많은 이슈가 있어서 <a href="https://facebook.github.io/react/">React</a>,
<a href="https://vuejs.org/">Vue</a>등으로 넘어가는 경우가 많은데,
저는 라이브러리/프레임워크의 복잡도가 문제였습니다.
저는 어떤 라이브러리/프레임워크를 사용할 때 내부 코드를 종종 살펴보는데 Angular는 쓸데없이 복잡하다는 생각이 들었습니다.</p>
<p>2014년 말, 2015년 초에는 React 얘기가 많이 나오기 시작하던 시기로 Angular와 React의 비교 글들이 많이 있었던 걸로 기억합니다.
그러던 와중에 Hacker News인가의 댓글로 Mithril이라는 프레임워크를 알게됐고, 소개글이 마음에 들었습니다.
다른 프레임워크에 비해서 속도가 빠르다는 얘기도 있었지만, 그 부분은 크게 문제가 되는 부분이 아니였고, 크기가 작다는 것이 마음에 들었습니다.</p>
<p>2015년 초에 시작한 지그재그 서비스의 내부 관리 사이트을 Mithril로 시작해서 그 후 작성한 모든 웹 어플리케이션은 Mithril을 사용하고 있습니다.</p>
<hr>
<p>2017년 4월 현재도 Mithril을 사용하고 있고, 올해 1.0으로 올라가면서 구조도 안정화됐습니다.
Mithril을 사용하면서 Grunt에서 <a href="http://gulpjs.com/">gulp</a>로 넘어갔다가 최근에는 <a href="https://webpack.js.org/">webpack</a>으로 전환했습니다.
언어는 여전히 CoffeeScript가 주요언어지만, <a href="https://www.typescriptlang.org/">TypeScript</a>로의 전환을 시작했습니다.</p>
<p>최근에는 <a href="https://vuejs.org/">Vue</a>가 꽤나 이슈가 되고 있는데 저는 계속 Mithril을 사용할 것 같습니다.</p>
<p>마지막으로 많은 프레임워크에 혼란을 겪으시는 분들을 위해 제가 생각하는 선택 기준을 말씀드리겠습니다.</p>
<ol>
<li>Angular: Spring 처럼 틀이 갖춰져 있어서, 잘 모르는 사람이 어느 정도 이상의 품질을 갖춘 제품을 만들고 싶을 때</li>
<li>React: 좋은 구조를 가진 제품을 만들고 싶고, 빠르게 발전하는 트랜드를 따라갈 자신이 있을 때</li>
<li>Vue: React와 비슷한 것을 원하지만 조금 더 안정된 것을 원할 때</li>
<li>Mithril: 복잡한 기능 필요없고 가급적 Vanilla JS에 가깝게 코드를 작성하고 싶을 때</li>
</ol>

        </div>
      </div>
      
      <div class='panel panel-default'>
        <div class='panel-heading'>
          <h2 class='posts-title'><a href='/ko/tech/2017-02-08-1-why-croquis-selects-nodejs/'>크로키가 Node.js를 선택한 이유</a></h2>
          <p class='posts-date'>08 Feb 2017</p>
        </div>
        <div class='panel-body'>
          <p>현재 크로키에서는 서버용 웹 프레임워크로 <a href="http://nodejs.org/">Node.js</a> 위에서
<a href="http://expressjs.com/">Express</a>를 사용하고 있습니다.</p>
<p>이번 글에서는 어떤 이유로 Node.js를 사용하게 되었는지 설명하려고 합니다.
여러분들이 웹 프레임워크를 선택하시는 데 참고가 되었으면 합니다.</p>
<hr>
<p>크로크닷컴을 설립한 것은 2012년 2월입니다.
회사를 차리면서 구상했던 것은 SNS 성격을 가진 서비스로 당연히 서버가 필요했습니다.
서버 프로그래밍은 2004년 무렵 Tomcat을 잠깐 써본 것이 전부였기 때문에
어떤 언어/프레임워크를 써야 하는지부터가 고민의 시작이었습니다.</p>
<p>몇 가지 후보군이 있었던 것으로 기억합니다.</p>
<p>첫 번째는 국내 웹에서 이미 많이 사용하고 있던 PHP입니다.</p>
<p>두 번째는 국내에서 또 많이 사용하는 ASP입니다.</p>
<p>세 번째는 대형 서비스에서 많이 사용하는 스프링입니다.
지금도 이력서를 받아보면 스프링을 사용/공부했다는 사람들이 종종 보입니다.</p>
<p>네 번째는 <a href="http://rubyonrails.org/">루비 온 레일즈</a>입니다.</p>
<p>마지막이 <a href="http://nodejs.org/">Node.js</a>입니다.
회사 설립 당시에 버전이 0.6이었는데, 국내에 책도 나오면서
이곳저곳에서 화제가 되었기에 살펴보았습니다.</p>
<p>그 외에 <a href="https://www.djangoproject.com/">장고</a>도 스타트업에서 많이 쓰이고
이력서에 장고를 사용했다는 사람이 심심치 않게 보이는데, 2012년 당시에
보면서도 그냥 지나쳤던 건지 널리 쓰이지 않았던 것인지 정확히 기억나지는 않지만,
후보로 고려하지 않았던 것 같습니다.</p>
<hr>
<p>PHP는 언어로서 완성도가 떨어진다고 생각하고 있었기에 배제를 했습니다.
또한, 서버로는 당연히 리눅스를 생각했기에 ASP도 바로 배제되었습니다.</p>
<p>스프링은 조금 고민이 되었지만, Tomcat을 통한 경험이 좋지 않아서
컴파일해서 배포해야 하는 프레임워크를 후보에서 제외했습니다.
(Tomcat과 스프링이 뭐가 다른 건지 잘 모르고,
10년 동안 많이 발전했을 수도 있지만, 워낙 거부감이 컸습니다.)</p>
<p>레일즈에 대해서는 지인에게 회의 중에 나온 내용을
바로바로 구현해가면서 확인해봤다는 무용담(?)을 들었던 적이 있고
2007년에 관련 책도 산 적이 있기에 (잘 보지는 않았지만),
일단 후보로 두었습니다.</p>
<p>Node.js는 당시에 여러 곳에서 빠르다는 이유로 주목받고 있었기에
레일즈와 두개를 주요 후보로 설정했습니다.</p>
<hr>
<p>정확히 비교하자만 레일즈=Express 이고, 루비=Node.js 겠죠.
레일즈는 이미 많은 기능이 있었고,
Express는 그에 비하면 단순한 기능만을 지원했습니다.
아마 저희가 웹 서비스를 만들려고 했다면 레일즈를 골랐을 수도 있습니다.
하지만 저희는 앱만 생각하고 있었기에 웹 프로토콜(HTTP) 요청만
처리할 수 있으면 됐습니다.
그리고 반대중적(?) 성격이 조금 있어서 레일즈가 제시하는 대로
프로그램을 만들어야 한다는 것이 썩 맘에 들지는 않았습니다.</p>
<p>그러나 무엇보다 Node.js를 선택한 결정적인 이유는 이벤트 주도 방식 때문입니다.
대학교에서 공부할 무렵부터 스레드와 락 개념을 별로 좋아하지 않았습니다.
스레드는 컨텐스트 전환에 불필요한 비용이 많이 든다고 생각했고,
데이터를 보호하기 위해서 락이 필요한데 문제 없이 작성하는 것이 어렵다고 봤습니다.
거기에 이벤트 주도 방식으로 단일 스레드에서 동작한다는 것이 제 취향에 맞았습니다.</p>
<p>Node.js를 선택하는데 당시 얘기가 많던 성능 문제는 크게 고려상황은 아니였습니다.
이벤트 주도 방식때문에 스레드 방식보다는 성능이 잘 나오는게 당연하다는 생각이 있었고,
다른 언어에서도 이벤트 주도 방식을 사용한다면 성능 차이는 그렇게 나지 않을 거라고 봤습니다.
(비슷하게 작성한다면 Java 같은 컴파일 언어가 당연히 성능이 좋을 것이라 생각했습니다.)
실제로 Node.js가 아니더라도 이벤트 주도 방식을 쓰는 Netty난 Twisted 같은 것도 이미 존재했습니다.
Node.js 가 뜬 이후에 나온 Vert.x 같은 것도 있고요.</p>
<hr>
<p>그럼에도 불구하고 Node.js를 선택한 것은 JavaScript라는 언어때문입니다.</p>
<p>프로토타입을 통한 상속이라던지,
this 바인딩등 보편적인 언어들과 다른 특성들 때문에 익히기 어려웠기에
사실 그다지 JavaScript는 좋아하는 언어는 아니였습니다.</p>
<p>일반적인 언어라면 어떤 것을 사용해서도 모든 일을 할 수 있다고 생각하고 있지만,
언어의 표현력에 따라 난이도는 달라집니다.
그런면에서 JavaScript는 개념이 색다르거나 잘못되어서(변수 스코프같은 경우),
제대로 사용하지 못하고 실수하기 좋은 언어라는 생각이 있었습니다.</p>
<p>하지만 이벤트 주도 방식에 대해서는 큰 장점이 있었습니다.
태생이 JavaScript는 브라우저 언어였기에 스레드에 대한 개념이 원래 고려되어 있지 않습니다.
(요새는 웹 워커 같은 것이 추가되고 있지만)
따라서 Node.js의 API는 모두 비동기적으로 동작하게 설계가 되어 있습니다.
반면 Java나 Python등의 언어에서는 이벤트 주도 방식으로 처리를 하려면,
원래 사용하던 API를 사용하면 안 되고 Java NIO나 Python asyncio 같은 것을 사용해야 합니다.</p>
<p>저는 이 차이가 제일 중요하다고 판단했습니다.
이벤트 주도 방식으로 서버를 작성하려면 블로킹 I/O를 사용하면 안 되는데,
언어/플랫폼 적으로 기본이 블로킹 I/O라면 의도치 않게 사용할 확률이 높다고 봤습니다.</p>
<hr>
<p>결론적으로 서버에는 이벤트 주도 방식이 가장 좋다고 생각했는데,
언어/플랫폼 태생적으로 이벤트 주도 방식인 Node.js를 사용하는 것이 맞다고 판단했습니다.</p>
<p>JavaScript의 단점은 CoffeeScript를 사용하는 것으로 회피했습니다.
다만 프로젝트가 커질 수록 형검사에 대한 요구가 커져서 TypeScript로
이전하는 것을 계속 고려중입니다.</p>
<p>콜백의 어려움은 초반에는 <a href="https://github.com/caolan/async">async</a>로,
현재는 Promise를 사용해서 피하고 있습니다.
TypeScript로 이전한 후에는 async/await를 사용해볼 예정입니다.</p>
<p>스프링이나 레일즈, 장고등에 비해 구인에 어려움은 조금 있지만,
현재는 Node.js를 선택한 것에 만족하고 있습니다.</p>

        </div>
      </div>
      
      <div class='panel panel-default'>
        <div class='panel-heading'>
          <h2 class='posts-title'><a href='/ko/tech/2017-01-15-1-process-unix-pipe-with-nodejs/'>Node.js로 유닉스 파이프 처리하기</a></h2>
          <p class='posts-date'>15 Jan 2017</p>
        </div>
        <div class='panel-body'>
          <p>크로키에서는 로그를 JSON 문자열로 만들어 일자별(혹은 시간별)로 묶은 후
gzip으로 압축해서 저장하고 있습니다.
그런데 이미 만들어진 로그를 수정해야 하는 일이 생겼습니다.</p>
<p>예를 들면</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">{</span><span class="s2">&#34;date&#34;</span><span class="o">:</span><span class="s2">&#34;Fri Jan 15 2016 00:00:01 GMT+0000 (UTC)&#34;</span><span class="p">,</span><span class="s2">&#34;path&#34;</span><span class="o">:</span><span class="s2">&#34;/foobar&#34;</span><span class="p">}</span>
<span class="p">{</span><span class="s2">&#34;date&#34;</span><span class="o">:</span><span class="s2">&#34;Fri Jan 15 2016 00:00:03 GMT+0000 (UTC)&#34;</span><span class="p">,</span><span class="s2">&#34;path&#34;</span><span class="o">:</span><span class="s2">&#34;/croquis&#34;</span><span class="p">}</span>
<span class="p">{</span><span class="s2">&#34;date&#34;</span><span class="o">:</span><span class="s2">&#34;Fri Jan 15 2016 00:00:10 GMT+0000 (UTC)&#34;</span><span class="p">,</span><span class="s2">&#34;path&#34;</span><span class="o">:</span><span class="s2">&#34;/awesome&#34;</span><span class="p">}</span></code></pre></div>
<p>였던 데이터를</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">{</span><span class="s2">&#34;date&#34;</span><span class="o">:</span><span class="s2">&#34;2016-01-15T00:00:01.000Z&#34;</span><span class="p">,</span><span class="s2">&#34;path&#34;</span><span class="o">:</span><span class="s2">&#34;/foobar&#34;</span><span class="p">}</span>
<span class="p">{</span><span class="s2">&#34;date&#34;</span><span class="o">:</span><span class="s2">&#34;2016-01-15T00:00:03.000Z&#34;</span><span class="p">,</span><span class="s2">&#34;path&#34;</span><span class="o">:</span><span class="s2">&#34;/croquis&#34;</span><span class="p">}</span>
<span class="p">{</span><span class="s2">&#34;date&#34;</span><span class="o">:</span><span class="s2">&#34;2016-01-15T00:00:10.000Z&#34;</span><span class="p">,</span><span class="s2">&#34;path&#34;</span><span class="o">:</span><span class="s2">&#34;/awesome&#34;</span><span class="p">}</span></code></pre></div>
<p>처럼 바꿔야 했습니다.</p>
<p>로그 전체를 읽어와서 줄별로 변환하고 다시 기록하면 되는 일이지만
로그가 커서 잘 동작하지 않았습니다.</p>
<p>그래서 유닉스의 파이프 형태로 처리하기로 했습니다.</p>
<p>위의 작업을 하는 Node.js 프로그램은 다음과 같습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">byline</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;byline&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">stream</span> <span class="o">=</span> <span class="nx">byline</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">);</span>
<span class="nx">stream</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">line</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">date</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">date</span><span class="p">).</span><span class="nx">toISOString</span><span class="p">();</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">data</span><span class="p">));</span>
<span class="p">});</span></code></pre></div>
<p><a href="https://github.com/jahewson/node-byline">byline</a>은 스트림을 줄별로 처리할 수 있게 해주는 모듈입니다.
줄별로 들어온 JSON 문자열을 파싱하고 원하는 처리를 한 후 다시 쓰기만 하는 단순한 코드입니다.
이 프로그램을 유닉스 파이프라인에 넣으면 원하는 결과를 얻을 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ gunzip -c original/01.data.gz <span class="p">|</span> node convert.js <span class="p">|</span> gzip &gt; converted/01.data.gz</code></pre></div>
<h3 id="보너스">보너스</h3>
<p>이 작업을 순수히 Node.js만 가지고도 할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">stream</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;stream&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">zlib</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;zlib&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">byline</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;byline&#39;</span><span class="p">);</span>

<span class="kr">class</span> <span class="nx">Convert</span> <span class="kr">extends</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">Transform</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">super</span><span class="p">(</span><span class="nx">options</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="mi">_</span><span class="nx">transform</span><span class="p">(</span><span class="nx">line</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>
    <span class="nx">data</span><span class="p">.</span><span class="nx">date</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">date</span><span class="p">).</span><span class="nx">toISOString</span><span class="p">();</span>
    <span class="nx">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;\n&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">fs</span><span class="p">.</span><span class="nx">createReadStream</span><span class="p">(</span><span class="s1">&#39;original/01.data.gz&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">zlib</span><span class="p">.</span><span class="nx">createGunzip</span><span class="p">())</span>
  <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">byline</span><span class="p">())</span>
  <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="k">new</span> <span class="nx">Convert</span><span class="p">())</span>
  <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">zlib</span><span class="p">.</span><span class="nx">createGzip</span><span class="p">())</span>
  <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">createWriteStream</span><span class="p">(</span><span class="s1">&#39;converted/01.data.gz&#39;</span><span class="p">));</span></code></pre></div>
<p>하지만 파이프의 특성상 하나의 프로그램이 하나의 작업만
할 수록 응용하기가 편해집니다.
예를 들어 파일이 로컬에 있는게 아니고 S3에 있다면
유닉스 파이프로는 다음과 같이 바꾸면 됩니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ aws s3 cp s3://mybucket/stream.txt - <span class="p">|</span> gunzip <span class="p">|</span> node convert.js <span class="p">|</span> gzip &gt; converted/01.data.gz</code></pre></div>
<p>Node.js로도 작성할 수 있지만 훨씬 많은 코드를 작성해야겠죠.</p>

        </div>
      </div>
      
    </div>

    
<div class='col-xs-12 text-center'>
  
  <ul class='pagination'>
    
    <li><a href='/ko/tech/'>&laquo; 처음</a></li>
    <li><a href='/ko/tech/page/4/'>&lt; 이전</a></li>
    

    
    <li class='disabled'><span>&hellip;</span></li>
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <li><a href='/ko/tech/page/3/'>3</a></li>
    
    
    
    
    
    <li><a href='/ko/tech/page/4/'>4</a></li>
    
    
    
    
    
    <li class='active'><span>5</span></li>
    
    
    
    
    
    <li><a href='/ko/tech/page/6/'>6</a></li>
    
    
    
    
    
    <li><a href='/ko/tech/page/7/'>7</a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    <li class='disabled'><span>&hellip;</span></li>
    

    
    <li><a href='/ko/tech/page/6/'>다음 &gt;</a></li>
    <li><a href='/ko/tech/page/12/'>끝 &raquo;</a></li>
    
  </ul>
  
</div>

  </div>

</div>

<div class='container-fluid'>
  <hr>
  <footer>
    <p>
      &copy; 2014-2021 Sangmin Yoon
      <span class='pull-right text-muted'>
        powered by
        <a href='https://gohugo.io/' target='_blank'>Hugo</a>
        ,
        <a href='http://getbootstrap.com/' target='_blank'>Bootstrap</a>
        ,
        <a href='http://www.dnsever.com' target='dnsever'><img src='http://banner.dnsever.com/dnsever-banner_62x15.gif'
            border='0' alt='DNS server, DNS service '></a>
      </span>
    </p>
  </footer>
</div>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-48366784-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script src='https://code.jquery.com/jquery-1.12.4.min.js'></script>
<script src='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js'></script>

</body>

</html>
