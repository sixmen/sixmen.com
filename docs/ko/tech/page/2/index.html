<!DOCTYPE html>
<html lang='ko'>

<head>
  <meta charset='utf-8'>

  
  <title>sixmen.com: Tech</title>
  
  
  <meta name='author' content='Sangmin Yoon'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0'>

  <link rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css'>
  <link href='/css/style.css?body=1' rel='stylesheet' type='text/css' media='all'>
  <link href='/css/syntax.css?body=1' rel='stylesheet' type='text/css' media='all'>

  <!--[if lt IE 9]>
  <script src='https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js'></script>
  <script src='https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js'></script>
  <![endif]-->
</head>

<body>
<div class='hp-navbar'>
  <div class='container-fluid'>
    <div class='row'>
      <div class='col-xs-12'>
        
        <nav class='hp-nav'>
          <a class='hp-nav-item'
            href='/ko/'>Home</a>
          <a class='hp-nav-item'
            href='/ko/mylife/'>MyLife</a>
          <a class='hp-nav-item'
            href='/ko/travel/'>Travel</a>
          <a class='hp-nav-item active'
            href='/ko/tech/'>Tech</a>
          <a class='hp-nav-item'
            href='/ko/tags/'>Tags</a>
          <a class='hp-nav-item pull-right' href='/en/'>English</a>
        </nav>
      </div>
    </div>
  </div>
</div>



<div class='container'>

  <div class='row' style='margin-top: 20px;'>

    <div class='col-sm-10 col-sm-offset-1'>
      
      <div class='panel panel-default'>
        <div class='panel-heading'>
          <h2 class='posts-title'><a href='/ko/tech/2022-10-04-1-understanding-graphql-1-schema/'>GraphQL 이해하기: (1) 스키마 정의</a></h2>
          <p class='posts-date'>04 Oct 2022</p>
        </div>
        <div class='panel-body'>
          <p><a href="https://graphql.org/">GraphQL</a>이란 것은 대부분 들어보셨을 것으로 생각합니다. 그리고 페이스북이 만들었다는 것 정도는 아실 것 같습니다. 근데 여기서 말하는 GraphQL이란 뭘까요?</p>
<p>GraphQL 자체는 데이터 query를 어떻게 할지만 정해놓았습니다.</p>
<p>즉</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-graphql" data-lang="graphql"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="py">id</span><span class="p">:</span><span class="w"> </span><span class="nc">ID</span><span class="p">!</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="py">name</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="p">!</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">type</span><span class="w"> </span><span class="nc">Query</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="py">user</span><span class="p">(</span><span class="py">id</span><span class="p">:</span><span class="w"> </span><span class="nc">ID</span><span class="p">!):</span><span class="w"> </span><span class="nc">User</span><span class="p">!</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>와 같이 정의된 스키마에</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-graphql" data-lang="graphql"><span class="line"><span class="cl"><span class="kd">query</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nc">user</span><span class="p">(</span><span class="py">id</span><span class="p">:</span><span class="w"> </span><span class="s">&#34;10&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nc">id</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="py">name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>와 같이 질의하면</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-graphql" data-lang="graphql"><span class="line"><span class="cl"><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="s">&#34;data&#34;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="s">&#34;user&#34;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="s">&#34;id&#34;</span><span class="p">:</span><span class="w"> </span><span class="s">&#34;10&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="s">&#34;name&#34;</span><span class="p">:</span><span class="w"> </span><span class="s">&#34;Simon&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>라는 결과만 내놓으면 됩니다.</p>
<p>하지만 개념이 간단하다고 그것을 동작하도록 구현하는 것까지 간단한 것은 아닙니다. GraphQL을 실제 제품에 적용하기까지는 많은 것들을 이해해야 합니다. 이에 대해 차례로 설명해보려고 합니다. 첫번째로 다뤄볼 내용은 스키마 정의입니다.</p>
<blockquote>
<p>언어나 구현체 별로 세부 내용이 다를 수도 있습니다. 따라서 앞으로 설명할 내용은 주로 참조 구현인 <a href="https://github.com/graphql/graphql-js">GraphQL.js</a>에 대한 내용이 됩니다. 여기에 더해서 대중적으로 많이 쓰이는 Java 계열의 라이브러리(<a href="https://www.graphql-java.com/">graphql-java</a>, <a href="https://netflix.github.io/dgs/">DGS Framework</a>등)를 일부 포함합니다. 다른 언어에서 사용하는 다른 라이브러리는 다른 생김새를 가지고 있을 수 있겠지만, 개념이 크게 다르지 않을 것으로 생각합니다.</p>
</blockquote>
<h2 id="날raw-객체를-사용해서-정의하기">날(raw) 객체를 사용해서 정의하기</h2>
<p>GraphQL 스키마는 GraphQLSchema 클래스의 인스턴스입니다. 이런 클래스들을 이용해 직접 정의할 수 있습니다. <a href="https://github.com/graphql/graphql-js#using-graphqljs">GraphQL.js의 코드</a>를 가져와 보겠습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tsx" data-lang="tsx"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">GraphQLObjectType</span><span class="p">,</span> <span class="nx">GraphQLSchema</span><span class="p">,</span> <span class="nx">GraphQLString</span><span class="p">,</span> <span class="nx">printSchema</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;graphql&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">schema</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">GraphQLSchema</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="nx">query</span>: <span class="kt">new</span> <span class="nx">GraphQLObjectType</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;RootQueryType&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fields</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">hello</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">type</span><span class="o">:</span> <span class="nx">GraphQLString</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">}),</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">printSchema</span><span class="p">(</span><span class="nx">schema</span><span class="p">));</span>
</span></span></code></pre></div><p>위 코드를 실행하면 다음과 같은 스키마가 만들어지는 것을 볼 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-graphql" data-lang="graphql"><span class="line"><span class="cl"><span class="kd">schema</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">query</span><span class="p">:</span><span class="w"> </span><span class="nc">RootQueryType</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nc">type</span><span class="w"> </span><span class="py">RootQueryType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="py">hello</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>RootQueryType를 Query로 바꾸면 좀 더 익숙한 스키마가 만들어집니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-graphql" data-lang="graphql"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nc">Query</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="py">hello</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>커스텀 타입도 추가할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tsx" data-lang="tsx"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">GraphQLList</span><span class="p">,</span> <span class="nx">GraphQLNonNull</span><span class="p">,</span> <span class="nx">GraphQLObjectType</span><span class="p">,</span> <span class="nx">GraphQLSchema</span><span class="p">,</span> <span class="nx">GraphQLString</span><span class="p">,</span> <span class="nx">printSchema</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;graphql&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">User</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">GraphQLObjectType</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;User&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">fields</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">name</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">type</span><span class="o">:</span> <span class="k">new</span> <span class="nx">GraphQLNonNull</span><span class="p">(</span><span class="nx">GraphQLString</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">schema</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">GraphQLSchema</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="nx">query</span>: <span class="kt">new</span> <span class="nx">GraphQLObjectType</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Query&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fields</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">users</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">type</span><span class="o">:</span> <span class="k">new</span> <span class="nx">GraphQLNonNull</span><span class="p">(</span><span class="k">new</span> <span class="nx">GraphQLList</span><span class="p">(</span><span class="k">new</span> <span class="nx">GraphQLNonNull</span><span class="p">(</span><span class="nx">User</span><span class="p">))),</span>
</span></span><span class="line"><span class="cl">      <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">}),</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">printSchema</span><span class="p">(</span><span class="nx">schema</span><span class="p">));</span>
</span></span></code></pre></div><p>위 코드는 다음과 같은 스키마를 정의한 것입니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-graphql" data-lang="graphql"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nc">Query</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="py">users</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="nc">User</span><span class="p">!]!</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">type</span><span class="w"> </span><span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="py">name</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="p">!</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>JVM 계열에서 기반이 되는 <a href="https://www.graphql-java.com/">graphql-java</a>는 이 형태의 스키마 생성을 지원합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">val</span> <span class="py">userType</span> <span class="p">=</span> <span class="n">GraphQLObjectType</span><span class="p">.</span><span class="n">newObject</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&#34;User&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="k">field</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">GraphQLFieldDefinition</span><span class="p">.</span><span class="n">newFieldDefinition</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&#34;name&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="n">type</span><span class="p">(</span><span class="n">GraphQLNonNull</span><span class="p">(</span><span class="n">GraphQLString</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">build</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="py">schema</span> <span class="p">=</span> <span class="n">GraphQLSchema</span><span class="p">.</span><span class="n">newSchema</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">query</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">GraphQLObjectType</span><span class="p">.</span><span class="n">newObject</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&#34;Query&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="k">field</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">GraphQLFieldDefinition</span><span class="p">.</span><span class="n">newFieldDefinition</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&#34;users&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">type</span><span class="p">(</span><span class="n">GraphQLNonNull</span><span class="p">(</span><span class="n">GraphQLList</span><span class="p">(</span><span class="n">GraphQLNonNull</span><span class="p">(</span><span class="n">userType</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">            <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">).</span><span class="n">build</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">println</span><span class="p">(</span><span class="n">SchemaPrinter</span><span class="p">().</span><span class="n">print</span><span class="p">(</span><span class="n">schema</span><span class="p">))</span>
</span></span></code></pre></div><p>이 방식은 간단한 스키마를 정의하는데도 많은 노력이 들고 틀릴 가능성도 높습니다. (다만 리졸버를 정의시 같이 포함할 수 있다는 장점은 있습니다.) 그래서 GraphQL 도입 초기에 예제만 보고 무조건 이렇게 해야 하는 것으로 알고 있을 때 잠깐만 사용했고, 현재는 이렇게 정의하지 않습니다. 다만 내부에서는 이 형태이기 때문에 이해하고 있으면 GraphQL 실행 최적화를 할 때 도움이 됩니다.</p>
<h2 id="스키마-정의-문자열에서-스키마-생성하기">스키마 정의 문자열에서 스키마 생성하기</h2>
<p>날 객체를 쓰는 것보다 좀 더 나은 방법은 스키마 정의 문자열에서 스키마를 생성하는 것입니다. buildSchema 함수를 사용하면 됩니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tsx" data-lang="tsx"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">buildSchema</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;graphql&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">schema</span> <span class="o">=</span> <span class="nx">buildSchema</span><span class="p">(</span><span class="sb">`
</span></span></span><span class="line"><span class="cl"><span class="sb">type User {
</span></span></span><span class="line"><span class="cl"><span class="sb">  name: String!
</span></span></span><span class="line"><span class="cl"><span class="sb">}
</span></span></span><span class="line"><span class="cl"><span class="sb">
</span></span></span><span class="line"><span class="cl"><span class="sb">type Query {
</span></span></span><span class="line"><span class="cl"><span class="sb">  users: [User!]!
</span></span></span><span class="line"><span class="cl"><span class="sb">}
</span></span></span><span class="line"><span class="cl"><span class="sb">`</span><span class="p">);</span>
</span></span></code></pre></div><p>이 방식은 스키마 우선(schema-first) 접근으로 불립니다. graphql-java도 이 방식을 지원하고, DGS도 이 방식을 사용합니다. 이렇게 생성한 스키마에 리졸버는 따로 붙여줘야 합니다.</p>
<p>다른 방식으로 <a href="https://github.com/apollographql/graphql-tag">graphql-tag</a> 모듈의 gql 태그를 쓰는 방법이 있습니다. 다만 이 태그는 parse 함수를 써서 GraphQLSchema 객체가 아닌 DocumentNode 객체를 만들어 내기 때문에, <a href="https://www.graphql-tools.com/docs/generate-schema">makeExecutableSchema</a>를 사용해 스키마 객체로 변환할 필요가 있습니다. 이 방식은 IDE에서 문법 강조가 되는 장점이 있었지만, 최근에는 gql 태그가 아니더라도 문법 강조가 되는 것으로 알고 있습니다. 그리고 저희는 현재 GraphQL 질의를 <code>.graphql</code> 파일로 만들어 문법 강조를 받고 있기 때문에 이 방식은 사용하지 않습니다. (오래전에 시도해서 아직 일부 코드에 흔적이 남아있습니다.)</p>
<h2 id="코드에서-스키마-생성하기">코드에서 스키마 생성하기</h2>
<p>또 다른 방법으로는 코드에서 스키마를 유도해 내는 것입니다. 이 방법은 기본 라이브러리에서 지원하지 않고 <a href="https://typegraphql.com/">TypeGraphQL</a>이라는 다른 라이브러리를 사용합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tsx" data-lang="tsx"><span class="line"><span class="cl"><span class="kr">import</span> <span class="s1">&#39;reflect-metadata&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">buildSchemaSync</span><span class="p">,</span> <span class="nx">ObjectType</span><span class="p">,</span> <span class="nx">Field</span><span class="p">,</span> <span class="nx">Resolver</span><span class="p">,</span> <span class="nx">Query</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;type-graphql&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">@ObjectType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">User</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">@Field</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nb">String</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">@Resolver</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">UserResolver</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">@Query</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">User</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">  <span class="nx">users</span><span class="p">()</span><span class="o">:</span> <span class="nx">User</span><span class="p">[]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">schema</span> <span class="o">=</span> <span class="nx">buildSchemaSync</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="nx">resolvers</span><span class="o">:</span> <span class="p">[</span><span class="nx">UserResolver</span><span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>이 방식은 코드 우선(code-first) 접근으로 불립니다. <a href="https://opensource.expediagroup.com/graphql-kotlin/docs/">GraphQL Kotlin</a>도 이 방식을 사용합니다.</p>
<p>리졸버 구현시 결국 코드로 된 모델(클래스)이 필요한데, 이 모델을 스키마 정의에 바로 사용할 수 있다는 장점이 있습니다. 그리고 같은 모델을 데이터베이스 테이블 정의에도 사용할 수 있다는 것(<a href="https://typeorm.io/">TypeORM</a>이나 <a href="https://croquiscom.github.io/cormo/">CORMO</a>를 사용해서)이 좋아보여서 한때 전체에 적용했었습니다.</p>
<p>하지만 막상 시간이 지나니 거슬리는 점들이 꽤 나왔습니다.</p>
<ul>
<li>GraphQL 모델(타입)과 데이터베이스 테이블이 미묘하게 달라서 한 클래스로 양쪽을 모두 지원하는게 어색한 경우가 많았습니다.</li>
<li>타 서비스에서 GraphQL API를 이용할 때, 서비스가 제공하는 GraphQL API(스키마)를 한눈에 보고 싶을 때가 있는데 코드와 스키마가 섞여서 전체를 한눈에 보기 어렵습니다.</li>
<li>원하는 스키마를 정의하기 위해 TypeGraphQL의 방식을 따로 배워야 합니다. 예를 들어 TypeScript 타입은 <code>User[]</code>로 쓰는데 타입 정의는 <code>[User]</code>로 해야 합니다. <code>[User]</code>, <code>[User!]</code>, <code>[User]!</code>, <code>[User!]!</code> 구분은 <code>nullable</code> 옵션으로 하는데 직관성이 아무래도 떨어진다고 보입니다.</li>
<li>TypeGraphQL로 안 되는 부분이 있었습니다. 당시에 enum의 주석을 추가하는게 불가능했고, 현재는 가능해졌지만 TypeScript의 한계로 자연스럽지 않습니다. (decorator를 사용하지 못하고, <code>registerEnumType</code>의 옵션으로 기술해야 합니다.)</li>
</ul>
<p>그래서 현재는 스키마 우선 접근을 사용하는 것으로 바뀌었습니다. 스키마 타입과 코드 클래스를 각기 정의해야 하는 단점도 <a href="https://www.graphql-code-generator.com/">GraphQL Code Generator</a> 같은 코드 생성기를 사용하면 어느 정도 해소가 됩니다.</p>

        </div>
      </div>
      
      <div class='panel panel-default'>
        <div class='panel-heading'>
          <h2 class='posts-title'><a href='/ko/tech/2022-08-28-1-prevent-deploy-invalid-branch/'>잘못된 브랜치 배포를 방지하기</a></h2>
          <p class='posts-date'>28 Aug 2022</p>
        </div>
        <div class='panel-body'>
          <p>반복해서 실수가 발생해서 수많은 사람들의 시간을 낭비하는데, 사실 시스템 개선에 조금만 시간을 썼으면 발생하지 않았을, 그런 문제들이 있습니다. 이런 상황을 알면서도 바쁘다는 핑계로 넘어가곤 하는데, 이번에 1년 이상 머리 한 구석에만 뒀던 이슈를 해결해 공유해볼까 합니다.</p>
<h2 id="문제">문제</h2>
<p>카카오스타일 정도의 규모에서는 당연히 어떤 기능을 프로덕션에 바로 배포하지 않습니다. 먼저 테스트 서버에 배포해 어느 정도 검증을 하고 프로덕션에 반영하게 됩니다. (물론 아무리 이런 과정을 거쳐도 문제는 발생하긴 합니다.) 카카오스타일은 스테이징 서버란 용어는 사용하지 않고, 알파란 용어를 사용하고 있습니다. 알파용 환경은 프로덕션 환경과 동일한 구조를 가지고 있지만, DB는 별개로 존재하는 환경입니다. (추가로 베타는 어플리케이션은 별도이지만, DB는 프로덕션을 사용하는 환경을 의미합니다. 피쳐 플래그 대신 주로 베타 환경을 이용해 최종 검증을 합니다.)</p>
<p>알파 환경은 하나이기 때문에 여러 팀이 동시에 작업하는 상황에서 충돌이 발생하곤 합니다. 어떤 기능을 알파에 배포해서 확인하던 도중에 다른 팀이 작업 덮어 씌워서 혼란이 발생하는데, 이를 완전히 막기는 어렵습니다. 이 부분은 일정 시간동안 알파 환경을 점유하겠다는 의사 표현을 하거나(아직 시스템화까진 생각하고 있지 않습니다), 알파 전 단계인 팀별 개발 환경을 만들어 해결하고 있습니다.</p>
<p>문제는 <strong>테스트도 끝나 정식으로 프로덕션까지 반영된 기능이 알파 환경에서 사라지는 케이스</strong>가 꽤 높은 비율로 발생한다는 점이였습니다. 오래전의 코드에서 브랜치를 만들어 내 기능을 작업한 이후에 최신 수정 사항을 제대로 반영하지 않은 채 알파에 배포를 하는 거죠. 나는 내 기능을 배포했을 뿐인데, 무관해 보이는 기능이 갑자기 동작하지 않으면서 이를 해결하기 위해 많은 사람들이 시간을 낭비하는 일이 발생하곤 했습니다.</p>
<p>해결책은 단순합니다. 정식으로 반영된 기능을 되돌리는 배포를 할 수 없게 막으면 됩니다. 다만 그동안 기술적 해결책을 찾지 못해, 규칙으로 정했지만(알파 배포시에는 main 브랜치를 포함해서 주세요!) 당연히 문제는 계속 발생했습니다.</p>
<h2 id="작업-내용">작업 내용</h2>
<p>카카오스타일도 당연히 배포 시스템이 갖춰져 있습니다. 명령을 내리면 GitHub에서 소스를 가져와 도커 이미지를 빌드하게 됩니다. 이때 브랜치도 같이 지정하게 됩니다. (프로덕션 배포시에는 브랜치가 고정 - 팀에 따라 master, main, release등을 사용 - 되어 있습니다.)</p>
<p>모든 소스를 가져오는 것은 오래 걸리기 때문에 얕은 복제(shallow clone)을 사용합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git clone git@github.com:croquiscom/<span class="nv">$SERVICE</span> -b <span class="nv">$BRANCH</span> --depth <span class="m">1</span> --jobs <span class="m">2</span>
</span></span></code></pre></div><p>이런 상황에서 배포하려는 브랜치가 주 브랜치(master, main)의 내용을 포함하고 있는지를 검사하는것이 이번 문제의 기술적인 이슈였습니다.</p>
<p>처음에는 복제(clone) 전에 브랜치 비교하는 방법을 찾아봤습니다. 하지만 아쉽게도 git 명령 중에 원격 저장소에서 동작하는 건 <a href="https://git-scm.com/docs/git-ls-remote.html">ls-remote</a> 밖에 없는 것 같습니다.</p>
<p>로컬 저장소에서 브랜치 비교는 가능하지만, 문제는 얕은 복제여서 브랜치간 비교가 불가능하다는 것이였습니다. 전체 복제 대신 처음 고민한 옵션은 깊이를 늘리는 것이였습니다(<code>--depth</code> 또는 <code>--shallow-since</code>). 복제시 지정한 브랜치만 받아졌기 때문에 <code>--no-single-branch</code> 옵션도 필요합니다. 다만 아무리 적당히 큰 값을 준다고해도 배포할 브랜치와 주 브랜치의 공통 조상이 복제에 포함될지 여부를 보장할 수 없는 문제가 있습니다.</p>
<p>그래도 얕은 복제 후 필요한 만큼 커밋을 더 받는 옵션을 찾아봤는데 deepen 옵션을 알게 됐습니다. 여기에 더해 <a href="https://stackoverflow.com/a/56113247">공통 조상이 발견될 때까지 원격에서 커밋을 가져오는 스크립트</a>를 스택오버플로우에서 발견하게 됩니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="k">while</span> <span class="o">[</span> -z <span class="k">$(</span> git merge-base master feature <span class="k">)</span> <span class="o">]</span><span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">  git fetch -q --deepen<span class="o">=</span><span class="m">1</span> origin master feature<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span>
</span></span></code></pre></div><p>위 스크립트가 동작하려면 master 브랜치도 로컬에 존재해야 하는데 <code>--no-single-branch</code> 옵션 대신 master 브랜치만 추가로 가져오는 건 <a href="https://github.com/rmacklin/fetch-through-merge-base">fetch-through-merge-base</a>라는 기능의 코드에서 찾았습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git fetch --depth<span class="o">=</span><span class="m">1</span> origin <span class="s2">&#34;+refs/heads/</span><span class="nv">$BASE_REF</span><span class="s2">:refs/heads/</span><span class="nv">$BASE_REF</span><span class="s2">&#34;</span>
</span></span></code></pre></div><p>이를 조합해 이미지 빌드 서버에 최종적으로 적용된 스크립트는 다음과 같습니다. (배포할 브랜치가 주 브랜치와 같은 경우에도 동작합니다.)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git clone git@github.com:croquiscom/<span class="nv">$SERVICE</span> -b <span class="nv">$BRANCH</span> --depth <span class="m">1</span> --jobs <span class="m">2</span>
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> <span class="nv">$SERVICE</span>
</span></span><span class="line"><span class="cl">git fetch --depth <span class="m">1</span> origin <span class="s2">&#34;+refs/heads/</span><span class="nv">$BASE_BRANCH</span><span class="s2">:refs/heads/</span><span class="nv">$BASE_BRANCH</span><span class="s2">&#34;</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s1">&#39;same branch&#39;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="o">[</span> -z <span class="s2">&#34;</span><span class="k">$(</span> git merge-base <span class="s2">&#34;</span><span class="nv">$BASE_BRANCH</span><span class="s2">&#34;</span> <span class="s2">&#34;</span><span class="nv">$BRANCH</span><span class="s2">&#34;</span> <span class="k">)</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">  git fetch -q --deepen<span class="o">=</span><span class="m">20</span> origin <span class="s2">&#34;</span><span class="nv">$BASE_BRANCH</span><span class="s2">&#34;</span> <span class="s2">&#34;</span><span class="nv">$BRANCH</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">[[</span> <span class="s2">&#34;</span><span class="k">$(</span>git rev-list --left-only --count <span class="nv">$BASE_BRANCH</span>...<span class="nv">$BRANCH</span><span class="k">)</span><span class="s2">&#34;</span> !<span class="o">=</span> <span class="s2">&#34;0&#34;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$BASE_BRANCH</span><span class="s2"> is not merged&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">exit</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="k">fi</span>
</span></span></code></pre></div><p><a href="https://git-scm.com/docs/git-rev-list">rev-list</a> 명령에서 <code>--count</code> 옵션을 사용하면 브랜치가 얼마나 앞서 있는지 수치로 알 수 있습니다. 주 브랜치(left)가 0 만큼 앞서 있다면 배포하려는 브랜치가 주 브랜치의 내용을 모두 포함하고 있다는 뜻이 됩니다.</p>
<h2 id="한편">한편..</h2>
<p>초기에 구축한 배포 시스템은 AWS의 <a href="https://aws.amazon.com/ko/codebuild/">CodeBuild</a>를 사용하고 있습니다. 한편 근래에 작업중인 서비스에서는 <a href="https://github.com/features/actions">GitHub Actions</a>를 사용중입니다. 위 방법은 GitHub Actions에도 역시 적용 가능하지만, GitHub API를 쓰면 복제전에 검사가 가능합니다. (사실 이쪽을 먼저 해결했다 보니, git만 가지고 원격에서 가능한 방식이 있나 한참 찾아봤습니다.)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl">- <span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">actions/github-script@v6</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">script</span><span class="p">:</span><span class="w"> </span><span class="p">|</span><span class="sd">
</span></span></span><span class="line"><span class="cl"><span class="sd">      const result = await github.rest.repos.compareCommitsWithBasehead({
</span></span></span><span class="line"><span class="cl"><span class="sd">        owner: context.repo.owner,
</span></span></span><span class="line"><span class="cl"><span class="sd">        repo: context.repo.repo,
</span></span></span><span class="line"><span class="cl"><span class="sd">        basehead: `master...${context.sha}`,
</span></span></span><span class="line"><span class="cl"><span class="sd">      });
</span></span></span><span class="line"><span class="cl"><span class="sd">      if (result.data.behind_by === 0) {
</span></span></span><span class="line"><span class="cl"><span class="sd">        return;
</span></span></span><span class="line"><span class="cl"><span class="sd">      }
</span></span></span><span class="line"><span class="cl"><span class="sd">      throw new Error(&#39;master not merged&#39;);</span><span class="w">      
</span></span></span></code></pre></div><h2 id="결론">결론</h2>
<p>몇 줄 안 되는 코드지만, 일반적으로 겪는 문제가 아니다보니 잠깐 검색해본 것으로는 잘 나오지 않는 내용이였습니다. 그러다보니 해결책을 찾는게 많이 미뤄진 것 같습니다. 하지만 마음 먹고 작업하니 하루에 끝날 정도의 분량이였고, 이게 적용되면 많은 시간 낭비를 없앨 것으로 기대됩니다.</p>
<p>이번에 작업한 내용과 유사하게 실수를 방지 하기 위한 조치를 하는 것을 <a href="https://ko.wikipedia.org/wiki/%ED%8F%AC%EC%B9%B4_%EC%9A%94%EC%BC%80">포카 요케</a>라고 부릅니다. 카카오스타일에서는 실수를 반복하지 않게 하기 위해 포카 요케 목록을 만들어 해결하는데 최근 많은 시간을 투자하고 있습니다.</p>

        </div>
      </div>
      
      <div class='panel panel-default'>
        <div class='panel-heading'>
          <h2 class='posts-title'><a href='/ko/tech/2022-04-09-1-esm-problem/'>ESM 삽질기</a></h2>
          <p class='posts-date'>09 Apr 2022</p>
        </div>
        <div class='panel-body'>
          <p>저희는 주기적으로 Node.js 모듈을 최신 버전으로 업데이트하고 있습니다.
Node.js를 10년째 사용 중인데, CoffeeScript → TypeScript, 콜백 → Async.js → Promise(&amp; async, await) 전환 하면서 몇 번 혼란의 시기가 있었습니다.
하지만 모듈 시스템은 쭉 이어져왔습니다.
그런데 최근에 이 모듈 시스템에 큰 변화가 생겼고 기존 변화와 다르게 양립이 잘 안 되서 모듈 업데이트를 제대로 못 하고 있습니다.
이 문제를 일으킨 ESM이 뭐고 어떤 작업이 필요한지 알아보려고 합니다. (개인적으로 만족하는 깔끔한 해결책이 나오지 못했습니다)</p>
<h2 id="발생하는-문제">발생하는 문제</h2>
<p><a href="https://www.npmjs.com/package/chalk">chalk</a> 란 모듈이 5.0으로 가면서 Pure ESM 모듈이 됐습니다. 이를 가져다 쓰면 다음과 같은 에러가 발생합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tsx" data-lang="tsx"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">chalk</span> <span class="kr">from</span> <span class="s1">&#39;chalk&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">chalk</span><span class="p">.</span><span class="nx">yellow</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">));</span>
</span></span></code></pre></div><pre tabindex="0"><code>Error [ERR_REQUIRE_ESM]: require() of ES Module /a/node_modules/chalk/source/index.js from /a/a.ts not supported.
Instead change the require of index.js in /a/a.ts to a dynamic import() which is available in all CommonJS modules.
</code></pre><h2 id="esm이란-무엇인가">ESM이란 무엇인가?</h2>
<p>초기 JavaScript는 모듈 시스템이 없었습니다.
클라이언트쪽에서는 <a href="https://requirejs.org/">Require.js</a>란 것이 많이 쓰였습니다.
한편 서버(Node.js)에서는 CommonJS가 적용되어 따로 발전을 했습니다.
라이브러리가 클라이언트, 서버를 모두 지원하기 위한 <a href="https://stackoverflow.com/questions/16521471/relation-between-commonjs-amd-and-requirejs">패턴들이 개발</a>되어 적용됐던 기억이 나네요.
그후 <a href="https://browserify.org/">Browserify</a>, <a href="https://webpack.js.org/">webpack</a> 같은 번들 시스템이 나오면서 CommonJS 쪽으로 통일되었습니다.</p>
<p>대부분의 경우 잘 동작하지만 뭔가 문제가 있으시까 새로운 시스템이 나왔겠죠? 상세한 히스토리는 잘 모르지만 제가 아는 CommonJS의 가장 큰 문제는 런타임에 모듈을 읽는 다는 것입니다.
다음 예를 보겠습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="c1">// a.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;a1&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./b&#39;</span><span class="p">).</span><span class="nx">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;a2&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">exports</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// b.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;b1&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./a&#39;</span><span class="p">).</span><span class="nx">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;b2&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">exports</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ node a.js 
</span></span><span class="line"><span class="cl">a1
</span></span><span class="line"><span class="cl">b1
</span></span><span class="line"><span class="cl">undefined
</span></span><span class="line"><span class="cl">b2
</span></span><span class="line"><span class="cl"><span class="m">2</span>
</span></span><span class="line"><span class="cl">a2
</span></span></code></pre></div><p>위의 예에서 보다시피 require는 그 줄에 다다를 때 실행됩니다.
순환 참조가 발생하는 경우(<code>require('./a')</code>) 모듈을 다시 읽지는 않습니다.
이때문에 주의를 기울이지 않으면 위 예처럼 모듈이 내보낸 값이 얻어지지 않는 문제가 발생할 수 있습니다.</p>
<p>TypeScript의 import문은 사실 require로 변환되는 코드이기 때문에 기존 컴파일 언어에 익숙하신 분이 보면 당황할만한 부분이 좀 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tsx" data-lang="tsx"><span class="line"><span class="cl"><span class="c1">// a.ts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;a1&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">b</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;./b&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;a2&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// b.ts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;b1&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">a</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;./a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;b2&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span></code></pre></div><pre tabindex="0"><code>$ ts-node a.ts 
a1
b1
undefined
b2
2
a2
</code></pre><p>아마 이런 저런 이유 때문에 <a href="https://nodejs.org/api/esm.html">ESM</a>이란 것이 나왔으리라 생각합니다.
(몇년전에 <code>.cjs</code>, <code>.mjs</code> 확장자 얘기가 나오는 글들 보면서 무슨 얘기가 진행되는 거야 라고 넘어간 기억이 있습니다.)</p>
<p>async/await 문법이 나온 이후에 가장 아쉬운 점 중 하나가 최상위 단계에서 await가 불가능하다는 것입니다.</p>
<pre tabindex="0"><code>$ cat a.js                                                                                                                                                                         1 ↵
await Promise.resolve(1);
$ node a.js 
/a/a.js:1
await Promise.resolve(1);
^^^^^

SyntaxError: await is only valid in async functions and the top level bodies of modules
</code></pre><p>따라서 함수를 만들거나 <a href="https://developer.mozilla.org/ko/docs/Glossary/IIFE">IIFE</a>를 사용해야 했습니다.
이것은 CommonJS의 한계로 인한 것이고 ESM에서는 가능해졌습니다.
이런 이유도 있어서 CommonJS에서 ESM 모듈을 require 하는 것이 불가능합니다.
반대로 ESM 모듈에서 CommonJS 모듈을 읽는 것은 가능하지만 신경써야 할 것들이 있습니다.</p>
<p>이렇게 ESM이 만들어진 후에 Sindre Sorhus란 분이 <a href="https://blog.sindresorhus.com/get-ready-for-esm-aa53530b3f77">ESM 전환을 선언</a>했습니다.
그리고 이 분이 만드는 많은 모듈들(예 <a href="https://www.npmjs.com/package/file-type">file-type</a>.
<a href="https://www.npmjs.com/~sindresorhus">npm 개인 홈</a>에 들어가보면 1165개의 모듈에 관여하고 있다고 나오네요)이 <a href="https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c">Pure ESM</a> 모듈로 전환됐습니다.
Pure ESM은 모듈이 CommonJS/ESM 양쪽을 지원하도록 구성할 수도 있지만, 굳이 ESM만 제공한다는 뜻입니다.</p>
<p>문제는 CommonJS 프로젝트에서는 ESM 모듈을 불러오는 것이 불가능하다는 것에 있습니다.
따라서 프로젝트가 ESM으로 전환해야지만 Pure ESM 모듈을 사용할 수 있습니다.</p>
<h2 id="무엇이-문제인가">무엇이 문제인가?</h2>
<h3 id="typescript에서-원인-찾기">TypeScript에서 원인 찾기</h3>
<p>위 예제에서 다시 시작하겠습니다</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tsx" data-lang="tsx"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">chalk</span> <span class="kr">from</span> <span class="s1">&#39;chalk&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">chalk</span><span class="p">.</span><span class="nx">yellow</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">));</span>
</span></span></code></pre></div><p>ts-node로 실행해보면 다음과 같은 에러가 발생합니다.</p>
<pre tabindex="0"><code>$ ts-node a.ts 
Error [ERR_REQUIRE_ESM]: require() of ES Module /a/node_modules/chalk/source/index.js from /a/a.ts not supported.
Instead change the require of index.js in /a/a.ts to a dynamic import() which is available in all CommonJS modules.
</code></pre><p>컴파일된 JavaScript 결과물을 보면 원인을 알 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="s2">&#34;use strict&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">exports</span><span class="p">.</span><span class="nx">__esModule</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">chalk_1</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&#34;chalk&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">chalk_1</span><span class="p">[</span><span class="s2">&#34;default&#34;</span><span class="p">].</span><span class="nx">yellow</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">));</span>
</span></span></code></pre></div><p>ESM 모듈은 require가 아니라 import를 해야 합니다.</p>
<h3 id="javascript에서-문제-해결">JavaScript에서 문제 해결</h3>
<p>TypeScript가 아니라 JavaScript로 import 구문을 사용해 작성해 봅니다. 이번에는 다른 에러가 납니다.</p>
<pre tabindex="0"><code>$ cat a.js 
import chalk from &#39;chalk&#39;;
console.log(chalk.yellow(&#39;Hello&#39;));
$ node a.js
(node:72179) Warning: To load an ES module, set &#34;type&#34;: &#34;module&#34; in the package.json or use the .mjs extension.
/a/a.js:1
import chalk from &#39;chalk&#39;;
^^^^^^

SyntaxError: Cannot use import statement outside a module
</code></pre><p>파일명을 <code>.mjs</code>로 바꾸면 잘 실행됩니다.</p>
<pre tabindex="0"><code>$ node a.mjs 
Hello
</code></pre><p>파일명을 바꾸는 대신 전체 프로젝트를 ESM을 사용하는 것으로 선언할 수 있습니다. package.json에 <code>&quot;type&quot;: &quot;module&quot;</code>을 추가합니다.</p>
<pre tabindex="0"><code>$ cat a.js 
import chalk from &#39;chalk&#39;;
console.log(chalk.yellow(&#39;Hello&#39;));
$ cat package.json 
{
  &#34;type&#34;: &#34;module&#34;,
  &#34;dependencies&#34;: {
    &#34;chalk&#34;: &#34;^5.0.1&#34;
  }
}
$ node a.js 
Hello
</code></pre><p>또는 TypeScript 실행시 보여준 에러 처럼 dynamic import를 사용할 수 있습니다.</p>
<pre tabindex="0"><code>$ cat a.js 
(async () =&gt; {
  const chalk = await import(&#39;chalk&#39;);
  console.log(chalk.default.yellow(&#39;Hello&#39;));
})();
$ node a.js 
Hello
</code></pre><p>정리하면 JavaScript에서 Pure ESM 모듈을 읽기 위해서는 다음 세가지 방법이 있습니다.</p>
<ul>
<li><code>.mjs</code> 확장자 사용</li>
<li>전체 프로젝트를 ESM으로 전환</li>
<li>dynamic import 사용</li>
</ul>
<h3 id="typescript로-되돌아-가서">TypeScript로 되돌아 가서</h3>
<p><code>.mts</code> 란 확장자도 인식하고, tsc로 컴파일 해보면 <code>.mjs</code>로 나오긴 하지만 적절한 변환은 안 됩니다.</p>
<p>dynamic import 구문을 사용해도 여전히 실행이 안 됩니다.
컴파일된 결과물을 보면 여전히 require로 변환이 됩니다.
이를 해결하려면 모듈시스템을 ES 것을 사용한다고 선언해야 합니다.
tsconfig에서 <a href="https://www.typescriptlang.org/tsconfig#module">module 설정</a>을 적절히 해줘야 합니다.</p>
<pre tabindex="0"><code>$ cat a.ts 
(async () =&gt; {
  const chalk = await import(&#39;chalk&#39;);
  console.log(chalk.default.yellow(&#39;Hello&#39;));
})();
$ cat tsconfig.json 
{
  &#34;compilerOptions&#34;: {
    &#34;target&#34;: &#34;es2017&#34;,
    &#34;module&#34;: &#34;es2020&#34;,
    &#34;moduleResolution&#34;: &#34;node&#34;
  }
}
$ ts-node a.ts 
Hello
</code></pre><p>import를 require로 변환하지 않고 그대로 두는 건 module 설정이지만, Node.js에서 import 구문을 이해하는 것을 별개입니다.
package.json에 <code>&quot;type&quot;: &quot;module&quot;</code> 도 추가하면 일반 import 구문도 동작합니다.
ts-node로 실행시에는 <code>--esm</code> 옵션을 줘야 동작합니다.</p>
<pre tabindex="0"><code>$ cat a.ts 
import chalk from &#39;chalk&#39;;
console.log(chalk.yellow(&#39;Hello&#39;));
$ cat package.json 
{
  &#34;type&#34;: &#34;module&#34;,
  &#34;dependencies&#34;: {...}
}
$ ts-node --esm a
Hello
$ tsc --module es2020 
$ cat a.js
import chalk from &#39;chalk&#39;;
console.log(chalk.yellow(&#39;Hello&#39;));
</code></pre><h2 id="실전-적용">실전 적용</h2>
<p>이제 ESM의 동작 원리에 대해 약간 감이 옵니다. (저는 이 글을 쓰면서 정리하는데도 아직도 헷갈립니다) 이제 실전 적용을 해봅니다.</p>
<p>JavaScript에서는 require와 dynamic import를 혼합해서 쓸 수 있습니다.
다시 말해 ESM 전환(<code>&quot;type&quot;: &quot;module&quot;</code>)을 하지 않아도 ESM 모듈을 쓰는 것이 가능합니다.
(static import가 안 되므로 코드를 다르게 작성하는 불편함은 있습니다.)</p>
<p>하지만 TypeScript에서는 import를 require로 변환 또는 모드 import로 유지, 두 가지 선택지 밖에 없습니다.
require로는 ESM 모듈을 쓸 수 없으므로 import 유지(<code>&quot;module&quot;: &quot;es2020&quot;</code>)를 해야 합니다.
이 경우 Node.js에서 import 구문을 사용하므로 ESM 전환(<code>&quot;type&quot;: &quot;module&quot;</code>)도 해야 합니다.</p>
<p>단순히 import 구문만 쓰면 되는게 아닙니다.
<a href="https://nodejs.org/api/esm.html#mandatory-file-extensions">불러올 파일의 확장자를 모두 기술</a>해줘야 합니다.
TypeScript 임에도 불구하고 <code>.js</code> 확장자를 써줘야 합니다.
또 저는 디렉토리명으로 import 하는 것을 종종 사용하는데 모두 파일명으로 바꿔줘야 합니다.
(<code>from './services' → from '.services/index.js'</code>) 이 과정을 도와주는 도구(<a href="https://www.npmjs.com/package/fix-esm-import-path">fix-esm-import-path</a>)도 있습니다.</p>
<p>샘플로 만들어본 프로젝트에서는 이걸로 동작했습니다.
하지만 실제 프로젝트로 가니 또 다른 이슈가 있었습니다.
<code>__dirname</code> 을 쓸 수 없다고 해서 변환을 해야 했습니다.
(예 <code>loadSchemaSync(join(__dirname, './index.graphql')</code>)</p>
<p>이제 컴파일도 되고 구동해봅니다. 안 됩니다. ESM 모듈에서는 require 구문을 쓰는게 아예 안 됩니다.</p>
<pre tabindex="0"><code>$ node a.js 
file:///a/a.js:1
const http = require(&#39;http&#39;);
             ^

ReferenceError: require is not defined in ES module scope, you can use import instead
This file is being treated as an ES module because it has a &#39;.js&#39; file extension and &#39;/a/package.json&#39; contains &#34;type&#34;: &#34;module&#34;. To treat it as a CommonJS script, rename it to use the &#39;.cjs&#39; file extension.
</code></pre><p>그런데 저희 주요 프로젝트 구조에는 TypeScript 내에서 require를 의존하는 곳이 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="c1">// tools/server.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">TZ</span> <span class="o">=</span> <span class="s1">&#39;Etc/UTC&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;ts-node/register/transpile-only&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;../app/server&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// config/index.ts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">loadConfig</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span><span class="nx">dir</span><span class="o">:</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">env</span><span class="o">?:</span> <span class="nx">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">base</span> <span class="o">=</span> <span class="nx">cloneDeep</span><span class="p">(</span><span class="nx">require</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">dir</span><span class="si">}</span><span class="sb">/default`</span><span class="p">).</span><span class="k">default</span> <span class="nx">as</span> <span class="nx">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>다른 건 몰라도 config는 당장 고치기 어려워 보였습니다.
또 즐겨쓰고 있는 <a href="https://github.com/croquiscom/rinore">REPL</a>도 제대로 동작을 안 하는 건 좀 심각했습니다.</p>
<h2 id="그래서-해결책은">그래서 해결책은?</h2>
<p>결국 이 이상 시간을 쏟기는 어려워서 어플리케이션을 ESM 모드로 전환하는 것은 포기했습니다.
하지만 ESM 모듈은 여전히 필요했습니다.</p>
<p>다행히 이번에 조사할 때는 저번에 찾지 못했던 <a href="https://github.com/TypeStrong/ts-node/discussions/1290">회피 방법</a>을 찾았습니다.
TypeScript가 변환하지 않도록 import 문을 감추는 것입니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Function</span><span class="p">(</span><span class="s1">&#39;specifier&#39;</span><span class="p">,</span> <span class="s1">&#39;return import(specifier)&#39;</span><span class="p">)</span>
</span></span></code></pre></div><p><a href="https://stackoverflow.com/a/70546326/3239514">eval도 가능</a>하다는데 테스트해보진 않았습니다.</p>
<p>다만 위 코드보다는 라이브러리를 활용하는 솔루션이 더 직관적인 것 같아서 이 방법을 사용했습니다.
<a href="https://www.npmjs.com/package/tsimportlib">tsimportlib</a> 라이브러리를 사용하면 됩니다.</p>
<p>아쉬운 대로 동작합니다만 나중에 프로젝트가 ESM으로 전환됐을 때 dynamic import를 static import로 바꿔줘야 할 것 같아 꼭 필요한 곳에만 쓰는 것으로 생각하고 있습니다.</p>
<p>다행히 dynamic import는 서버에서만 필요했고, 프론트엔드 코드에서는 Next.js등이 잘 처리해주는지 static import로도 잘 동작했습니다.</p>
<h2 id="마무리">마무리</h2>
<p>개인적인 느낌으로 ESM은 Python2 → Python3를 전환시의 혼란을 보는 것 같습니다.
저를 포함해 많은 사람들이 당황해하고 불만을 터트리네요</p>
<p><img src="/img/ko/tech/2022-04-09-1-01.png" alt="https://github.com/sindresorhus/meta/discussions/15#discussioncomment-2495719">
<a href="https://github.com/sindresorhus/meta/discussions/15#discussioncomment-2495719">https://github.com/sindresorhus/meta/discussions/15#discussioncomment-2495719</a></p>
<p>하지만 좋은 싫든 ESM으로의 전환은 시작된 것 같습니다.
조금 더 생태계가 안정되면 다시 전환 시도를 해야 할 것 같습니다.</p>
<h2 id="appendix">Appendix</h2>
<ul>
<li><a href="https://nodejs.org/api/esm.html">Modules: ECMAScript modules | Node.js Documentation</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Modules">JavaScript modules - JavaScript | MDN</a></li>
<li><a href="https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1">Node Modules at War: Why CommonJS and ES Modules Can’t Get Along</a> (<a href="https://roseline.oopy.io/dev/translation-why-cjs-and-esm-cannot-get-along">번역</a>, <a href="https://yceffort.kr/2020/08/commonjs-esmodules">요약</a>)</li>
<li><a href="https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c">Pure ESM package</a></li>
<li><a href="https://blog.sindresorhus.com/get-ready-for-esm-aa53530b3f77">Get Ready For ESM. JavaScript Modules will soon be a… | by Sindre Sorhus | 🦄 Sindre Sorhus’ blog</a></li>
<li><a href="https://docs.joshuatz.com/cheatsheets/node-and-npm/node-esm/">ES Modules in NodeJS - Troubleshooting Resources</a></li>
<li><a href="https://github.com/TypeStrong/ts-node/discussions/1290">Dynamic `import()` with `&ldquo;module&rdquo;: &ldquo;commonjs&rdquo;`</a></li>
<li><a href="https://typestrong.org/ts-node/docs/imports/">CommonJS vs native ECMAScript modules | ts-node</a></li>
<li><a href="https://www.npmjs.com/package/tsimportlib">tsimportlib</a></li>
</ul>

        </div>
      </div>
      
    </div>

    
<div class='col-xs-12 text-center'>
  
  <ul class='pagination'>
    
    <li><a href='/ko/tech/'>&laquo; 처음</a></li>
    <li><a href='/ko/tech/'>&lt; 이전</a></li>
    

    

    
    
    
    
    <li><a href='/ko/tech/'>1</a></li>
    
    
    
    
    
    <li class='active'><span>2</span></li>
    
    
    
    
    
    <li><a href='/ko/tech/page/3/'>3</a></li>
    
    
    
    
    
    <li><a href='/ko/tech/page/4/'>4</a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    <li class='disabled'><span>&hellip;</span></li>
    

    
    <li><a href='/ko/tech/page/3/'>다음 &gt;</a></li>
    <li><a href='/ko/tech/page/16/'>끝 &raquo;</a></li>
    
  </ul>
  
</div>

  </div>

</div>

<div class='container-fluid'>
  <hr>
  <footer>
    <p>
      &copy; 2014-2021 Sangmin Yoon
      <span class='pull-right text-muted'>
        powered by
        <a href='https://gohugo.io/' target='_blank'>Hugo</a>
        ,
        <a href='http://getbootstrap.com/' target='_blank'>Bootstrap</a>
        ,
        <a href='http://www.dnsever.com' target='dnsever'><img src='http://banner.dnsever.com/dnsever-banner_62x15.gif'
            border='0' alt='DNS server, DNS service '></a>
      </span>
    </p>
  </footer>
</div>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-48366784-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script src='https://code.jquery.com/jquery-1.12.4.min.js'></script>
<script src='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js'></script>

</body>

</html>
